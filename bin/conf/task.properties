# 在集群中每个实例都必须有一个唯一的instanceId，但是应该有一个相同的instanceName【默认“QuartzScheduler”】【非必须】
org.quartz.scheduler.instanceName=Task
# 如果你想quartz-scheduler出口本身通过RMI作为服务器，然后设置“出口”标志true(默认值为false)。
org.quartz.scheduler.rmi.export=false
# 如果export和proxy同时指定为true，则export的设置将被忽略
org.quartz.scheduler.rmi.proxy=false
# 如果想使用Quartz在执行一个job前使用UserTransaction，则应该设置该属性为true。job执行完、在JobDataMap改变之后事务会提交。默认值是false。 可以在你的job类中使用 @ExecuteInJTATransaction注解, 可以控制job是否使用事务。【默认false】【非必须】
org.quartz.scheduler.wrapJobExecutionInUserTransaction=false
# 线程池的实现类（定长线程池，几乎可满足所有用户的需求）【默认null】【必须】
org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool
# 指定线程数，至少为1（无默认值）(一般设置为1-100直接的整数合适)【默认-1】【必须】
org.quartz.threadPool.threadCount=5
# 设置线程的优先级（最大为java.lang.Thread.MAX_PRIORITY 10，最小为Thread.MIN_PRIORITY 1）【默认Thread.NORM_PRIORITY (5)】【非必须】
org.quartz.threadPool.threadPriority=5
# 
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread=true
# 最大能忍受的触发超时时间(触发器被认定为“misfired”之前)，如果超过则认为“失误”【默认60秒】
org.quartz.jobStore.misfireThreshold=60000
# 将schedule相关信息保存在RAM中，轻量级，速度快，遗憾的是应用重启时相关信息都将丢失。
org.quartz.jobStore.class=org.quartz.simpl.RAMJobStore